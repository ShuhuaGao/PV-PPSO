"""
Photovoltaic models. Single-diode model (SDM) and double-diode model (DDM).
"""
module PV
using CUDA

export sdm, ddm, sse, sse_sdm, sse_ddm

const k = 1.3806503e-23     # Boltzmann constant
const q = 1.60217646e-19    # electron charge 

const k32 = 1.3806503f-23     # Boltzmann constant
const q32 = 1.60217646f-19    # electron charge 

"""
    sdm(V, I, T, Iph, I0, n, Rs, Rp)

Single diode model with five parameters
- V, I are the input voltage and current.
- T: temperature in Calvin (K)
- Iph:  photocurrent generated by the solar cell (A)
- I0: the reverse saturation current of the diode (μA)
- n: diode ideality factor
- Rs: series resistance (Ω)
- Rp: parallel resistance (Ω)
"""
function sdm(V, I, T, Iph, I0, n, Rs, Rp)
    tmp = V + I * Rs
    s = 1e-6
    return Iph - I0 * s * (exp(q * tmp / (n * k * T)) - 1) - tmp / Rp
end

function sdm(V::Float32, I::Float32, T::Float32, Iph::Float32, I0::Float32, n::Float32, Rs::Float32, Rp::Float32)
    tmp = V + I * Rs
    s = 1f-6
    return Iph - I0 * s * (exp(q32 * tmp / (n * k32 * T)) - 1) - tmp / Rp
end

"""
    ddm(V, I, T, Iph, I01, I02, n1, n2, Rs, Rp)

Double diode model with seven parameters
- V, I are the input voltage and current.
- T: temperature in Calvin (K)
- Iph:  photocurrent generated by the solar cell (A)
- I01, I02: the reverse saturation current of the diode (μA)
- n1, n2: diode ideality factor
- Rs: series resistance (Ω)
- Rp: parallel resistance (Ω)
"""
function ddm(V, I, T, Iph, I01, I02, n1, n2, Rs, Rp)
    tmp = V + I * Rs
    c = k * T / q
    s = 1e-6
    return Iph - I01 * s * (exp(tmp / (n1 * c)) - 1) - I02 * s * (exp(tmp / (n2 * c)) - 1) - tmp / Rp
end

function ddm(V::Float32, I, T, Iph, I01, I02, n1, n2, Rs, Rp)
    tmp = V + I * Rs
    c = k32 * T / q32
    s = 1f-6
    return Iph - I01 * s * (exp(tmp / (n1 * c)) - 1) - I02 * s * (exp(tmp / (n2 * c)) - 1) - tmp / Rp
end


"""
    sse(data::AbstractMatrix, T::AbstractFloat, model::Function, x::AbstractVector)

For a given parameter vector `x`, compute the SSE (sum of squared error) using the `model` and
experimental voltage-current points in `data`.

- data: each column is a (V, I) point
- T: temperature in Calvin (K)
- model: either `sdm` or `ddm`
- x: a parameter vector
"""
function sse(data::AbstractMatrix{TF}, T::TF, model::Function, 
            x::AbstractVector{TF}) where TF <: AbstractFloat
    res = zero(eltype(x))
    for (V, I) in eachcol(data)
        Ic = model(V, I, T, x...)  # calculated current
        res += (Ic - I)^2
    end
    return res
end

"""
    sse_sdm(data::AbstractMatrix{TF}, T::TF, x::AbstractVector{TF}) where TF <: AbstractFloat

Compute SSE for `data` using SDM. This function is intended to be used in a CUDA kernel.
See [`sdm`](@ref) and [`sse`](@ref) for more details.
"""
function sse_sdm(data::AbstractMatrix{TF}, T::TF, x::AbstractVector{TF}) where TF <: AbstractFloat
    res = zero(TF)
    @inbounds for (V, I) in eachcol(data)
        Ic = sdm(V, I, T, x[1], x[2], x[3], x[4], x[5])  # calculated current
        res += (Ic - I)^2
    end
    return res
end

"""
    sse_ddm(data::AbstractMatrix{TF}, T::TF, x::AbstractVector{TF}) where TF <: AbstractFloat

Compute SSE for `data` using dDM. This function is intended to be used in a CUDA kernel.
See [`ddm`](@ref) and [`sse`](@ref) for more details.
"""
function sse_ddm(data::AbstractMatrix{TF}, T::TF, x::AbstractVector{TF}) where TF <: AbstractFloat
    res = zero(TF)
    @inbounds for (V, I) in eachcol(data)
        Ic = ddm(V, I, T, x[1], x[2], x[3], x[4], x[5], x[6], x[7])  # calculated current
        res += (Ic - I)^2
    end
    return res
end

end # module
